from typing import Iterable

import numpy as np
import pandas as pd

from .formula import TraitFormula


def calcu_derived_trait(
    abund_df: pd.DataFrame,
    meta_prop_df: pd.DataFrame,
    formulas: list[TraitFormula],
) -> pd.DataFrame:
    """Calculate the derived trait values.

    Args:
        abund_df (pd.DataFrame): The abundance table, with samples as index and Compositions
            as columns.
        meta_prop_df (pd.DataFrame): The table of meta properties generated by
            `build_meta_property_table`.
        formulas (list[TraitFormula]): The trait formulas.

    Returns:
        pd.DataFrame: The trait values, with samples as index and trait names as columns.
    """
    trait_series: list[pd.Series] = []
    for formula in formulas:
        formula.initialize(meta_prop_df)
        trait_s = pd.Series(
            data=formula.calcu_trait(abund_df),
            index=abund_df.index,
            name=formula.name,
            dtype=float,
        )
        trait_series.append(trait_s)
    derived_trait_df = pd.concat(trait_series, axis=1)
    derived_trait_df = derived_trait_df.round(6)
    return derived_trait_df


def filter_invalid(trait_df: pd.DataFrame) -> pd.DataFrame:
    """Rule out the invalid traits.

    A trait is invalid if it:
    1. Has the same value for all samples.
    2. Is NaN for all samples.

    Args:
        trait_df (pd.DataFrame): The trait values, with samples as index and trait names
            as columns.

    Returns:
        pd.DataFrame: The filtered trait values.
    """
    trait_df = _filter_all_same(trait_df)
    trait_df = _filter_all_nan(trait_df)
    return trait_df


def _filter_all_same(trait_df: pd.DataFrame) -> pd.DataFrame:
    """Rule out the traits that have the same value for all samples."""
    return trait_df.loc[:, trait_df.nunique() != 1]


def _filter_all_nan(trait_df: pd.DataFrame) -> pd.DataFrame:
    """Rule out the traits that are NaN for all samples."""
    return trait_df.loc[:, trait_df.notna().any()]


def filter_colinearity(
    formulas: Iterable[TraitFormula],
    derived_traits_table: pd.DataFrame,
    threshold: float,
) -> set[TraitFormula]:
    """Filter the colinearity of the formulas.

    Args:
        formulas (Iterable[TraitFormula]): The formulas to be filtered.
        derived_traits_table (pd.DataFrame): The derived traits table, after post-filtering.
        threshold (float): The threshold of the correlation coefficient.

    Returns:
        An array of bool, indicating whether the corresponding trait should be kept.
        The array is in the order of the column of `derived_traits_table`.
    """
    trait_names = list(derived_traits_table.columns)

    # First, build the parent-child relationship matrix.
    # This matrix consists of 0 and 1.
    # If the i-th row and j-th column is 1, then the i-th trait is the child of the j-th trait.
    rela_matrix = _relationship_matrix(trait_names, formulas)

    # Second, build the correlation matrix.
    # This matrix also consists of 0 and 1.
    # 1 means the two traits are highly correlated (r > the threshold).
    corr_matrix = _correlation_matrix(derived_traits_table, threshold)

    # Third, multiply the two matrices.
    # If the i-th row and j-th column is 1,
    # then the i-th trait is the child of the j-th trait,
    # and the two traits are highly correlated.
    # Then the i-th trait should be removed.
    # That is to say, if the row sum of the i-th row is larger than 0,
    # then the i-th trait should be removed.
    remove_matrix = rela_matrix * corr_matrix
    to_keep = np.sum(remove_matrix, axis=1) == 0

    return to_keep


def _relationship_matrix(trait_names: Iterable[str], formulas: Iterable[TraitFormula]):
    """Build the parent-child relationship matrix.

    This matrix consists of 0 and 1.
    If the i-th row and j-th column is 1, then the i-th trait is the child of the j-th trait.

    Args:
        trait_names (Iterable[str]): The names of the traits.
        formulas (Iterable[TraitFormula]): The formulas to be filtered.

    Returns:
        np.ndarray: The relationship matrix.
    """
    trait_names = list(trait_names)
    formula_dict = {
        formula.name: formula for formula in formulas if formula.name in trait_names
    }
    matrix = np.zeros((len(trait_names), len(trait_names)), dtype=int)
    for i, trait_1 in enumerate(trait_names):
        for j, trait_2 in enumerate(trait_names):
            formula_1 = formula_dict[trait_1]
            formula_2 = formula_dict[trait_2]
            if formula_1.is_child_of(formula_2):
                matrix[i, j] = 1
    return matrix


def _correlation_matrix(trait_table: pd.DataFrame, threshold: float):
    """Build the correlation matrix.

    This matrix also consists of 0 and 1.
    1 means the two traits are highly correlated (r > the threshold).

    Args:
        trait_table (pd.DataFrame): The derived traits table, after post-filtering.
        threshold (float): The threshold of the correlation coefficient.

    Returns:
        np.ndarray: The correlation matrix.
    """
    corr_matrix = trait_table.corr().values >= threshold
    corr_matrix = corr_matrix.astype(int)
    return corr_matrix
