import pandas as pd

from .formula import TraitFormula


def calcu_derived_trait(
    abund_df: pd.DataFrame,
    meta_prop_df: pd.DataFrame,
    formulas: list[TraitFormula],
) -> pd.DataFrame:
    """Calculate the derived trait values.

    Args:
        abund_df (pd.DataFrame): The abundance table, with samples as index and Compositions
            as columns.
        meta_prop_df (pd.DataFrame): The table of meta properties generated by
            `build_meta_property_table`.
        formulas (list[TraitFormula]): The trait formulas.

    Returns:
        pd.DataFrame: The trait values, with samples as index and trait names as columns.
    """
    trait_series: list[pd.Series] = []
    for formula in formulas:
        formula.initialize(meta_prop_df)
        trait_s = pd.Series(
            data=formula.calcu_trait(abund_df),
            index=abund_df.index,
            name=formula.name,
            dtype=float,
        )
        trait_series.append(trait_s)
    derived_trait_df = pd.concat(trait_series, axis=1)
    derived_trait_df = derived_trait_df.round(6)
    return derived_trait_df


def filter_derived_trait(trait_df: pd.DataFrame) -> pd.DataFrame:
    """Rule out the invalid traits.

    A trait is invalid if it:
    1. Has the same value for all samples.
    2. Is NaN for all samples.

    Args:
        trait_df (pd.DataFrame): The trait values, with samples as index and trait names
            as columns.

    Returns:
        pd.DataFrame: The filtered trait values.
    """
    trait_df = _filter_all_same(trait_df)
    trait_df = _filter_all_nan(trait_df)
    return trait_df


def _filter_all_same(trait_df: pd.DataFrame) -> pd.DataFrame:
    """Rule out the traits that have the same value for all samples."""
    return trait_df.loc[:, trait_df.nunique() != 1]


def _filter_all_nan(trait_df: pd.DataFrame) -> pd.DataFrame:
    """Rule out the traits that are NaN for all samples."""
    return trait_df.loc[:, trait_df.notna().any()]
